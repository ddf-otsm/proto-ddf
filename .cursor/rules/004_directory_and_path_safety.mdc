---
description: "USE WHEN working with directory operations, path handling, or file system navigation to ensure safety and prevent errors"
globs: ["**/*.sh", "**/*.bash", "**/*.zsh", "**/*.js", "**/*.ts", "**/*.py"]
alwaysApply: false
---

# DIRECTORY AND PATH SAFETY

## Directory Context Safety

### Critical Directory Safety Rules
- **ALWAYS verify current directory** before executing any file operations
- **NEVER assume directory context** without explicit verification
- **Use absolute paths** for critical operations
- **Implement directory validation** before destructive operations

### Directory Detection Pattern
```bash
# ✅ MANDATORY: Verify directory before operations
if [ ! -d "/expected/directory/path" ]; then
    echo "ERROR: Not in expected directory"
    exit 1
fi

# ✅ MANDATORY: Check if in project root
if [ ! -f "package.json" ] || [ ! -d ".git" ]; then
    echo "ERROR: Not in project root directory"
    exit 1
fi
```

## Pre-Command Directory Verification

### Basic Template with Directory Verification
```bash
#!/bin/bash
set -euo pipefail

# Directory verification
EXPECTED_DIR="/path/to/project"
CURRENT_DIR=$(pwd)

if [ "$CURRENT_DIR" != "$EXPECTED_DIR" ]; then
    echo "ERROR: Script must be run from $EXPECTED_DIR"
    echo "Current directory: $CURRENT_DIR"
    exit 1
fi

# Project markers verification
if [ ! -f "package.json" ] || [ ! -d ".git" ]; then
    echo "ERROR: Not in a valid project directory"
    exit 1
fi

# Continue with operations...
```

### File-Specific Operations Template
```bash
#!/bin/bash
set -euo pipefail

# File existence verification
TARGET_FILE="$1"
if [ ! -f "$TARGET_FILE" ]; then
    echo "ERROR: Target file does not exist: $TARGET_FILE"
    exit 1
fi

# Directory writable verification
TARGET_DIR=$(dirname "$TARGET_FILE")
if [ ! -w "$TARGET_DIR" ]; then
    echo "ERROR: Directory not writable: $TARGET_DIR"
    exit 1
fi

# Continue with file operations...
```

## Directory Detection Utility

### Comprehensive Directory Validation
```bash
# ✅ GOOD: Complete directory validation function
validate_directory_context() {
    local expected_markers=("package.json" ".git" "workflows/run.sh")
    local current_dir=$(pwd)

    echo "Current directory: $current_dir"

    for marker in "${expected_markers[@]}"; do
        if [ ! -e "$marker" ]; then
            echo "ERROR: Missing expected file/directory: $marker"
            echo "This script must be run from the project root"
            exit 1
        fi
    done

    echo "Directory validation passed"
}

# Call at start of every script
validate_directory_context
```

## Common Directory Pitfalls Prevention

### Pitfall 1: Relative Path Assumptions
```bash
# ❌ BAD: Assumes current directory
cd scripts/
./deploy.sh

# ✅ GOOD: Explicit path verification
if [ -d "scripts" ]; then
    cd scripts/
    ./deploy.sh
else
    echo "ERROR: scripts directory not found"
    exit 1
fi
```

### Pitfall 2: Implicit Directory Dependencies
```bash
# ❌ BAD: Silent dependency on directory structure
source config/settings.sh

# ✅ GOOD: Explicit validation
if [ -f "config/settings.sh" ]; then
    source config/settings.sh
else
    echo "ERROR: Configuration file not found"
    exit 1
fi
```

### Pitfall 3: Destructive Operations Without Verification
```bash
# ❌ BAD: Dangerous without directory verification
rm -rf build/

# ✅ GOOD: Safe with proper verification
if [ -d "build" ] && [ "$(pwd)" = "/expected/project/path" ]; then
    timeout 10 rm -rf build/
else
    echo "ERROR: Build directory not found or wrong location"
    exit 1
fi
```

## Safe RM Workaround

### Problem: Safe RM Alias Interference
Some systems have a `safe_rm` alias that prevents normal `rm` operations. This can interfere with legitimate file operations.

### Workaround Solutions
```bash
# Method 1: Use full path to rm
timeout 10 /bin/rm -f temp_file.txt

# Method 2: Bypass alias with backslash
timeout 10 \rm -f temp_file.txt

# Method 3: Use unalias temporarily
unalias rm 2>/dev/null || true
timeout 10 rm -f temp_file.txt

# Method 4: Use find with delete
timeout 10 find . -name "temp_file.txt" -delete
```

### Safe Deletion Best Practices
```bash
# ✅ GOOD: Move to trash instead of direct deletion
move_to_trash() {
    local file="$1"
    local trash_dir="/trash_git"

    # Ensure trash directory exists
    mkdir -p "$trash_dir"

    # Move file with timestamp
    local timestamp=$(date +"%Y%m%d_%H%M%S")
    timeout 10 mv "$file" "$trash_dir/$(basename "$file")_$timestamp"

    echo "Moved $file to trash: $trash_dir"
}

# Usage
move_to_trash "unwanted_file.txt"
```

## Path Handling Best Practices

### Path Validation
```bash
# ✅ GOOD: Comprehensive path validation
validate_path() {
    local path="$1"
    local path_type="$2"  # file, directory, or either

    # Check if path exists
    if [ ! -e "$path" ]; then
        echo "ERROR: Path does not exist: $path"
        return 1
    fi

    # Check path type
    case "$path_type" in
        "file")
            if [ ! -f "$path" ]; then
                echo "ERROR: Not a file: $path"
                return 1
            fi
            ;;
        "directory")
            if [ ! -d "$path" ]; then
                echo "ERROR: Not a directory: $path"
                return 1
            fi
            ;;
        "either")
            # Path exists, type doesn't matter
            ;;
        *)
            echo "ERROR: Invalid path type specified: $path_type"
            return 1
            ;;
    esac

    return 0
}
```

### Directory Localization
```bash
# ✅ GOOD: Localize directory operations
execute_in_directory() {
    local target_dir="$1"
    local command="$2"
    local original_dir=$(pwd)

    # Validate target directory
    if [ ! -d "$target_dir" ]; then
        echo "ERROR: Target directory does not exist: $target_dir"
        return 1
    fi

    # Change to target directory
    cd "$target_dir" || {
        echo "ERROR: Failed to change to directory: $target_dir"
        return 1
    }

    # Execute command
    eval "$command"
    local exit_code=$?

    # Return to original directory
    cd "$original_dir" || {
        echo "WARNING: Failed to return to original directory: $original_dir"
    }

    return $exit_code
}

# Usage
execute_in_directory "src/" "timeout 30 npm run build"
```

## Environment and Context Validation

### Project Root Detection
```bash
# ✅ GOOD: Reliable project root detection
find_project_root() {
    local current="$(pwd)"

    while [ "$current" != "/" ]; do
        if [ -f "$current/package.json" ] && [ -d "$current/.git" ]; then
            echo "$current"
            return 0
        fi
        current="$(dirname "$current")"
    done

    echo "ERROR: Project root not found"
    return 1
}

# Usage
PROJECT_ROOT=$(find_project_root)
if [ $? -eq 0 ]; then
    cd "$PROJECT_ROOT"
else
    exit 1
fi
```

### Working Directory Safety
```bash
# ✅ GOOD: Safe working directory management
with_safe_working_directory() {
    local target_dir="$1"
    local operation="$2"
    local original_pwd="$(pwd)"

    # Create a trap to ensure we return to original directory
    trap "cd '$original_pwd'" EXIT

    # Validate and change to target directory
    if [ -d "$target_dir" ]; then
        cd "$target_dir"
        eval "$operation"
    else
        echo "ERROR: Invalid working directory: $target_dir"
        return 1
    fi
}
```

This rule consolidates all directory operations, path handling, file system navigation, and safety procedures.
