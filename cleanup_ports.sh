#!/bin/bash

################################################################################
#                    PROTO-DDF PORT CLEANUP SCRIPT
################################################################################
#
# NAME
#   cleanup_ports.sh - Clean up and free ports used by Proto-DDF applications
#
# SYNOPSIS
#   ./cleanup_ports.sh [OPTIONS]
#
# DESCRIPTION
#   This script identifies and kills any leftover processes on ports used by
#   the Proto-DDF generator interface and generated applications, freeing them
#   for reuse. Useful when applications crash or don't shut down cleanly.
#
#   The script:
#   - Reads port configuration from config/.port_config.json
#   - Checks frontend and backend ports for both generator and apps
#   - Gracefully terminates processes (kill -15)
#   - Provides detailed feedback on each port's status
#   - Ensures ports are available before completing
#
# USAGE
#   ./cleanup_ports.sh              # Cleanup all default ports
#   ./cleanup_ports.sh --verbose    # Show detailed output
#   ./cleanup_ports.sh --force      # Force kill processes (kill -9)
#   ./cleanup_ports.sh --help       # Show this help message
#
# OPTIONS
#   --verbose, -v      Show detailed output for each operation
#   --force, -f        Use force kill (kill -9) instead of graceful (kill -15)
#   --help, -h         Display this help message
#
# ENVIRONMENT
#   CONFIG_FILE        Path to port configuration (default: config/.port_config.json)
#   FORCE_MODE         Set to 1 to force kill processes
#   VERBOSE_MODE       Set to 1 to show detailed output
#
# EXIT CODES
#   0 - Port cleanup completed successfully, all ports are free
#   1 - Config file not found (ports cannot be determined)
#   2 - Port detection failed (lsof not available or permission denied)
#   3 - Some processes could not be terminated
#   4 - Invalid command line arguments
#
# FILES
#   config/.port_config.json  - Port configuration (auto-generated by run.sh)
#   Format: {"backend": 3539, "frontend": 3797, "generated_backend": 4984, "generated_frontend": 3459}
#
# EXAMPLES
#   # Clean up all ports
#   ./cleanup_ports.sh
#
#   # Clean up with verbose output
#   ./cleanup_ports.sh --verbose
#
#   # Force kill lingering processes
#   ./cleanup_ports.sh --force
#
# NOTES
#   - Requires lsof utility (built-in on macOS/Linux)
#   - May require elevated privileges to kill some processes
#   - Non-fatal: continues even if unable to terminate some processes
#   - Skips ports that are already free
#   - Automatically called by run.sh before starting generator
#
# REQUIREMENTS
#   - bash 4.0+
#   - lsof utility
#   - Standard Unix tools (kill, sleep)
#
# AUTHOR
#   Proto-DDF Development Team
#
# SEE ALSO
#   ./run.sh          - Main application runner
#   ./scripts/run_e2e_tests.sh - E2E test runner
#
################################################################################

set -e  # Exit on error (unless in non-fatal blocks)

# Configuration
FORCE_MODE=0
VERBOSE_MODE=0
EXIT_CODE=0

################################################################################
# LOGGING FUNCTIONS
################################################################################

# Display information message
log_info() {
    echo "ℹ️  $1" >&2
}

# Display success message
log_success() {
    echo "✅ $1" >&2
}

# Display warning message
log_warning() {
    echo "⚠️  WARNING: $1" >&2
}

# Display error message
log_error() {
    echo "❌ ERROR: $1" >&2
}

# Display progress message
log_progress() {
    echo "🔄 $1" >&2
}

# Display verbose-only message
log_verbose() {
    if [ "$VERBOSE_MODE" -eq 1 ]; then
        echo "📝 $1" >&2
    fi
}

# Display header
log_header() {
    echo ""
    echo "╔════════════════════════════════════════════════════════════════╗"
    echo "║         🧹 PROTO-DDF PORT CLEANUP                              ║"
    echo "╚════════════════════════════════════════════════════════════════╝"
    echo ""
}

# Display footer
log_footer() {
    echo ""
    echo "╔════════════════════════════════════════════════════════════════╗"
    if [ "$EXIT_CODE" -eq 0 ]; then
        echo "║  ✅ Port cleanup complete! Ports are ready to use.            ║"
    else
        echo "║  ⚠️  Port cleanup completed with some warnings.               ║"
    fi
    echo "╚════════════════════════════════════════════════════════════════╝"
    echo ""
}

# Display help message
show_help() {
    cat << 'EOF'
Usage: ./cleanup_ports.sh [OPTIONS]

Clean up and free ports used by Proto-DDF applications by terminating
any processes listening on configured ports.

OPTIONS:
  --verbose, -v      Show detailed output for each operation
  --force, -f        Use force kill (kill -9) instead of graceful (kill -15)
  --help, -h         Display this help message

EXAMPLES:
  ./cleanup_ports.sh              # Standard cleanup
  ./cleanup_ports.sh --verbose    # With detailed output
  ./cleanup_ports.sh --force      # Force kill lingering processes
  ./cleanup_ports.sh --help       # Show this help

PORTS MANAGED:
  - Generator Backend   (FastAPI server)
  - Generator Frontend  (React UI server)
  - Generated App Backend   (FastAPI servers for generated apps)
  - Generated App Frontend  (React UI servers for generated apps)

EXIT CODES:
  0 - Success: all ports freed
  1 - Config file not found
  2 - Port detection failed
  3 - Some processes could not be terminated
  4 - Invalid arguments

See the script header for full documentation.
EOF
}

################################################################################
# COMMAND LINE PARSING
################################################################################

while [[ $# -gt 0 ]]; do
    case "$1" in
        --help|-h)
            show_help
            exit 0
            ;;
        --verbose|-v)
            VERBOSE_MODE=1
            log_verbose "Verbose mode enabled"
            shift
            ;;
        --force|-f)
            FORCE_MODE=1
            log_verbose "Force mode enabled (kill -9)"
            shift
            ;;
        *)
            log_error "Unknown option: $1"
            show_help
            exit 4
            ;;
    esac
done

################################################################################
# MAIN LOGIC
################################################################################

log_header
log_info "Starting port cleanup process..."
echo ""

# Validate prerequisites
if ! command -v lsof &> /dev/null; then
    log_error "lsof utility not found"
    log_info "lsof is required to identify processes on ports"
    log_info "Install it with: brew install lsof (macOS) or apt install lsof (Linux)"
    exit 2
fi

# Check if config file exists
CONFIG_FILE="config/.port_config.json"
if [ ! -f "$CONFIG_FILE" ]; then
    log_error "Config file not found: $CONFIG_FILE"
    log_info "Run ./run.sh once to generate port configuration"
    exit 1
fi

log_verbose "Config file found: $CONFIG_FILE"

# Extract ports from config or use dynamic fallback
log_progress "Reading port configuration..."

BACKEND_PORT=$(python3 -c "
import json
try:
    with open('$CONFIG_FILE') as f:
        config = json.load(f)
        print(config.get('backend', '3539'))
except:
    # Dynamic fallback
    import random, socket
    def is_available(port):
        try:
            with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as sock:
                sock.bind(('0.0.0.0', port))
                return True
        except:
            return False
    for port in [3539] + [random.randint(3000, 5000) for _ in range(10)]:
        if is_available(port):
            print(port)
            break
" 2>/dev/null || echo "3539")

FRONTEND_PORT=$(python3 -c "
import json
try:
    with open('$CONFIG_FILE') as f:
        config = json.load(f)
        print(config.get('frontend', '3797'))
except:
    # Dynamic fallback
    import random, socket
    def is_available(port):
        try:
            with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as sock:
                sock.bind(('0.0.0.0', port))
                return True
        except:
            return False
    for port in [3797] + [random.randint(3000, 5000) for _ in range(10)]:
        if is_available(port):
            print(port)
            break
" 2>/dev/null || echo "3797")

GENERATED_BACKEND_PORT=$(python3 -c "
import json
try:
    with open('$CONFIG_FILE') as f:
        config = json.load(f)
        print(config.get('generated_backend', '4984'))
except:
    # Dynamic fallback
    import random, socket
    def is_available(port):
        try:
            with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as sock:
                sock.bind(('0.0.0.0', port))
                return True
        except:
            return False
    for port in [4984] + [random.randint(3000, 5000) for _ in range(10)]:
        if is_available(port):
            print(port)
            break
" 2>/dev/null || echo "4984")

GENERATED_FRONTEND_PORT=$(python3 -c "
import json
try:
    with open('$CONFIG_FILE') as f:
        config = json.load(f)
        print(config.get('generated_frontend', '3459'))
except:
    # Dynamic fallback
    import random, socket
    def is_available(port):
        try:
            with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as sock:
                sock.bind(('0.0.0.0', port))
                return True
        except:
            return False
    for port in [3459] + [random.randint(3000, 5000) for _ in range(10)]:
        if is_available(port):
            print(port)
            break
" 2>/dev/null || echo "3459")

log_success "Ports detected:"
echo "  Backend (generator):      $BACKEND_PORT"
echo "  Frontend (generator):     $FRONTEND_PORT"
echo "  Backend (generated apps): $GENERATED_BACKEND_PORT"
echo "  Frontend (generated apps):$GENERATED_FRONTEND_PORT"
echo ""

################################################################################
# PROCESS TERMINATION FUNCTION
################################################################################

kill_port_processes() {
    local port=$1
    local port_name=$2
    local kill_mode=$3  # -15 for graceful, -9 for force

    log_verbose "Checking port $port ($port_name)..."

    # Get PIDs listening on the port
    PIDS=$(lsof -ti :$port 2>/dev/null || true)

    if [ -n "$PIDS" ]; then
        log_warning "Found process(es) on port $port ($port_name): $PIDS"

        if [ "$kill_mode" -eq 9 ]; then
            log_progress "Force killing processes on port $port ($port_name): $PIDS"
            echo "$PIDS" | xargs kill -9 2>/dev/null || true
        else
            log_progress "Terminating processes on port $port ($port_name): $PIDS"
            echo "$PIDS" | xargs kill -15 2>/dev/null || true
        fi

        sleep 1

        # Check if still running
        if lsof -ti :$port >/dev/null 2>&1; then
            log_error "Some processes may still be running on port $port"
            EXIT_CODE=3
        else
            log_success "Port $port ($port_name) is now free"
        fi
    else
        log_verbose "Port $port ($port_name) is already free"
        log_success "Port $port ($port_name) is free"
    fi
}

################################################################################
# CLEANUP EXECUTION
################################################################################

# Determine kill mode
if [ "$FORCE_MODE" -eq 1 ]; then
    log_warning "Using force mode (kill -9)"
    KILL_MODE=9
else
    KILL_MODE=15
fi

echo ""

# Kill processes on all ports
kill_port_processes "$BACKEND_PORT" "generator-backend" $KILL_MODE
kill_port_processes "$FRONTEND_PORT" "generator-frontend" $KILL_MODE
kill_port_processes "$GENERATED_BACKEND_PORT" "generated-app-backend" $KILL_MODE
kill_port_processes "$GENERATED_FRONTEND_PORT" "generated-app-frontend" $KILL_MODE

log_footer
echo "💡 You can now run: ./run.sh"
echo ""

exit $EXIT_CODE
